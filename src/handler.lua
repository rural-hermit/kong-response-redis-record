---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 86159.
--- DateTime: 2019/10/12 14:12
---
local BasePlugin = require "kong.plugins.base_plugin"
local CacheHandler = BasePlugin:extend()
local kong = kong
local redis = require "resty.redis"
local socket = require "socket"
local cjson_decode = require("cjson").decode
local cjson_encode = require("cjson").encode

local function json_decode(json)
    if json then
        local status, res = pcall(cjson_decode, json)
        if status then
            return res
        end
    end
end

local function json_encode(table)
    if table then
        local status, res = pcall(cjson_encode, table)
        if status then
            return res
        end
    end
end

local function connect_to_redis(conf)
    local red = redis:new()

    red:set_timeout(conf.redis_timeout)

    local ok, err = red:connect(conf.redis_host, conf.redis_port)
    if err then
        return nil, err
    end

    if conf.redis_password and conf.redis_password ~= "" then
        local ok, err = red:auth(conf.redis_password)
        if err then
            return nil, err
        end
    end

    return red
end

local function redis_list_set(premature, key, val, conf)
    local red, err = connect_to_redis(conf)
    if err then
        kong.log(ngx.ERR, "failed to connect to Redis: ", err)
    end
    red:init_pipeline()

    red:lpush(key, val)

    local results, err = red:commit_pipeline()
    if err then
        kong.log(ngx.ERR, "failed to commit the pipelined requests: ", err)
    end
end

function CacheHandler:new()
    CacheHandler.super.new(self, "response-cache")
end
function PrintTable( tbl , level, filteDefault)
    local msg = ""
    filteDefault = filteDefault or true --默认过滤关键字（DeleteMe, _class_type）
    level = level or 1
    local indent_str = ""
    for i = 1, level do
        indent_str = indent_str.."  "
    end

    print(indent_str .. "{")
    for k,v in pairs(tbl) do
        if filteDefault then
            if k ~= "_class_type" and k ~= "DeleteMe" then
                local item_str = string.format("%s%s = %s", indent_str .. " ",tostring(k), tostring(v))
                print(item_str)
                if type(v) == "table" then
                    PrintTable(v, level + 1)
                end
            end
        else
            local item_str = string.format("%s%s = %s", indent_str .. " ",tostring(k), tostring(v))
            print(item_str)
            if type(v) == "table" then
                PrintTable(v, level + 1)
            end
        end
    end
    print(indent_str .. "}")
end

function getCharLength(str)
    str = str or ""
    local strLength = 0
    local len = string.len(str)
    while str do
        local fontUTF = string.byte(str,1)

        if fontUTF == nil then
            break
        end
        --lua中字符占1byte,中文占3byte
        if fontUTF > 127 then
            local tmp = string.sub(str,1,3)
            strLength = strLength+1
            str = string.sub(str,4,len)
        else
            local tmp = string.sub(str,1,1)
            strLength = strLength+1
            str = string.sub(str,2,len)
        end
    end
    return strLength
end

function CacheHandler:access(conf)
    CacheHandler.super.access(self)

    local red, err = connect_to_redis(conf)
    if err then
        kong.log(ngx.ERR, "failed to connect to Redis: ", err)
        return
    end
    kong.log("connect to Redis success : ")
    --此处先写入流量统计总key值，如果该key值对应的list中存在，则等待，如果不存在，则直接写入
    local service_table = kong.router.get_service()
    local response_host = service_table["host"]
    local request_ip= kong.client.get_forwarded_ip()
    local traffic_key_time = os.date("%Y%m%d")
    local traffic_key = tostring(traffic_key_time) .. "-traffic"
    local traffic_value = traffic_key_time .. "-" .. response_host

    --此处直接通过 traffic_value.作为key 值，获取对应的list ,如果不存在，先写入第一层redis list
    local rlist, err = red:lrange(traffic_value, 0, 1)
    -- 此处返回的table 元素下标从1开始，如果下表为1的元素为nil，表示该key值对应的value为空，需要创建该key值，对应的一级缓存，
    if (rlist[1] == nil) then
        kong.log(traffic_key, " : ", traffic_value)
        red:lpush(traffic_key, traffic_value)
    end

    local request_time = socket.gettime()

    ngx.ctx.response_cache = {
        request_time = request_time,
        traffic_value = traffic_value,
        request_ip = request_ip,
        response_host = response_host
    }
end

function CacheHandler:header_filter(conf)
    CacheHandler.super.header_filter(self)
    kong.log("enter into header_filter ...")

end

function CacheHandler:body_filter(conf)
    CacheHandler.super.body_filter(self)
    kong.log("enter into body_filter ...")

    local ctx = ngx.ctx.response_cache
    kong.log(ctx.request_time)
    if not ctx then
        return
    end
    --此处判断返回值状态吗是否为200,不是直接返回。
    local response_status = kong.service.response.get_status()
    kong.log("response_status : ", response_status)
    if (response_status ~= 200) then
        return
    end
    --获取当前的基本参数
    local response_time = socket.gettime()

    local request_time = ctx.request_time
    local used_time_differ =string.format("%.4f", (response_time - request_time))
    local traffic_value = ctx.traffic_value
    local request_ip = ctx.request_ip
    local response_host = ctx.response_host
    -- 此处先获取当前响应投中是否含有Transfer-Encoding →chunked 消息头，如果有说明时chunk编码，需要计算长度，
    -- 如果没有，则可以直接通过content-length 消息头属性获取响应报文长度
    local transfer_encoding = kong.service.response.get_header("Transfer-Encoding")
    --kong.log("transfer_encoding : ", transfer_encoding)
    local chunk = ngx.arg[1]
    local eof = ngx.arg[2]

    if transfer_encoding then

        local response_body = ctx and ctx.response_body or ""
        response_body = response_body .. (chunk or "")
        ctx.response_body = response_body
        if eof then

            local response_content_length = getCharLength(tostring(ctx.response_body))
            local traffic_response_json = {
                create_time = os.date("%Y-%m-%d %H:%M:%S"),
                request_time = request_time,
                response_time = response_time,
                request_ip = request_ip,
                response_host = response_host,
                used_time_differ = used_time_differ,
                response_content_length = response_content_length,
            }
            local value_json = json_encode(traffic_response_json)

            kong.log("traffic_value : ", traffic_value, "value_json : ", value_json)
            ngx.timer.at(0, redis_list_set, traffic_value, value_json, conf)
        end
    else
        if eof then

            local response_content_length = kong.service.response.get_header("Content-Length")
            local traffic_response_json = {
                create_time = os.date("%Y-%m-%d %H:%M:%S"),
                request_time = request_time,
                response_time = response_time,
                request_ip = request_ip,
                response_host = response_host,
                used_time_differ = used_time_differ,
                response_content_length = response_content_length,
            }
            local value_json = json_encode(traffic_response_json)

            kong.log("traffic_value : ", traffic_value, "value_json : ", value_json)
            ngx.timer.at(0, redis_list_set, traffic_value, value_json, conf)
        end
    end
end

return CacheHandler